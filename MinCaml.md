Прискорений курс MinCaml компілятора
====================================
Ейдзіро Суміі, Університет Токіо

Зміст
-----

* Що це?
* Makefile проєкту MinCaml
* Головна програма
* Синтаксис і типи MinCaml
* Політика компіляції
* Лексичний аналіз
* Парсер
* Вивід типів
* K-нормалізація
* α-конверсія
* β-редукція
* Редукція вкладених let
* Inline експансія
* Згортка констант
* Елімінація необов'язкових дефініцій
* Closure Conversion
* Генерація байткоду і компіляція бінарного коду
* Оптимізація безпосередніх операндів
* Алокація регістрів
* Генерація асемблерного коду

Що це?
------

Цей документ є підручником з описом MinCaml,
компілятора підмножини мови програмування ML.
Компілятор MinCaml розроблено в дослідницькому
програмному проекті «Красивий компілятор ML у Японії»
з метою популяризації простої та потужної мови програмування ML
і розриву негативної спіралі «Я не використовую ML,
тому що я не знаю ML». Він реалізований на мета мові
ML під назвою Objective Caml. Оскільки цей підручник
передбачає певний досвід програмування ML як передумову,
будь ласка, спочатку подивіться «Programmin in ML» Роберта Харпера.

[Застереження: цей підручник англійською мовою є попереднім
перекладом японської версії та все ще може мати багато недоліків,
як технічно, так і лінгвістично. Академічна стаття більш повна.]

[Оновлення від 17 вересня 2008 р.: тепер підтримується
PowerPC (на додаток до SPARC), завдяки пані Масуко та
професору Асаї з університету Очаномідзу. Ви повинні
виконати ./to_ppc або ./to_sparc перед make.]

[Ще одне оновлення від 17 вересня 2008 р.: розподільник
регістрів тепер використовує простіший алгоритм. У попередніх
версіях відсутнє зворотне відстеження (ToSpill і NoSpill).]

[Оновлення від 27 серпня 2012 р.: тепер підтримується
x86 із SSE2 (Pentium 4 або новіша версія). Будь ласка,
виконайте ./to_x86 перед make.]

Makefile проєкту MinCaml
------------------------

Після завантаження компілятора MinCaml перегляньте його Makefile.
Тут описано, як скомпілювати сам MinCaml.

Makefile MinCaml використовує зручний інструмент під назвою
OCamlMakefile (рядок містить OCamlMakefile внизу). Просто
перерахувавши файли, необхідні для MinCaml у рядку SOURCES = ...,
ви можете створити байт-код інтерпретатор min-caml, виконавши
команду "make byte-code". Подібним чином ви можете отримати
нативний код min-caml.opt за допомогою "make native-code".
Крім того, "make top" створює інтерактивне середовище OCaml
верхнього рівня min-caml.top, де за замовчуванням
завантажуються модулі MinCaml. Це зручно для дебага та експериментів.

Makefile MinCaml також має функцію автоматичного тестування.
Помістіть код ML "program-name.ml" у каталог test, напишіть 
назву програми в рядку TESTS = ... і запустіть "make do_test".
Потім результат, створений OCaml (назва-програми.ans) і результат
(назва-програми.res) збірки, згенерованої MinCaml (назва-програми.s),
автоматично порівнюються, а їх різниця виводиться в "назва-програми.cmp".
Зазвичай він порожній, тому що не повинно бути ніякої різниці,
поки компіляція та виконання вдалися.

Вам потрібне середовище SPARC з компілятором gcc і асемблером
для виконання скомпільованої програми. Однак це не обов'язково
для простого створення збірки SPARC.

Головна програма
----------------

Далі подивіться на основну програму MinCaml main.ml. Виконання
компілятора починається з його низу let () = ....

По-перше, ми обробляємо параметри за допомогою стандартної
бібліотеки Arg OCaml. Параметр -inline вказує максимальний
розмір функцій, які будуть вбудовані, а -iter визначає
максимальну кількість оптимізацій для ітерації. (Деталі будуть пояснені пізніше.)

Інші аргументи командного рядка вважаються іменами програм,
які збираються. Функція Main.file генерує збірку SPARC "назва-програми.s"
із джерела ML «назва-програми.ml».

Для налагодження та експериментів також надається функція Main.string,
яка компілює рядковий аргумент і відображає результат у стандартному виводі.

Ядром main.ml є функція Main.lexbuf. За наявності аргументу буфера
він застосовується в такому порядку: лексичний аналіз (Lexer.token),
аналіз (Parser.exp), визначення типу (Typing.f), K-нормалізація (KNormal.f),
α-перетворення (Alpha.f). ), оптимізації (iter), перетворення
закриття (Closure.f), генерація коду віртуальної машини (Virtual.f),
13-розрядна негайна оптимізація SPARC (Simm13.f), розподіл
реєстрів (RegAlloc.f) і генерація складання (Emit) .f).

Функція оптимізації iter повторює наступні п’ять оптимізацій,
доки її результат не перестане змінюватися або кількість ітерацій
не досягне верхньої межі, визначеної -iter: β-зменшення (Beta.f),
зменшення вкладеного let (Assoc.f), вбудоване розширення (Inline.f),
постійне згортання (ConstFold.f) і видалення непотрібних визначень (Elim.f).

Незабаром ми пояснимо подробиці цих перекладів і оптимізацій.

Синтаксис і типи MinCaml
------------------------

MinCaml є підмножиною ML. За винятком деяких деталей,
таких як пріоритет і круглі дужки, він має такий синтаксис.

```
e ::= вирази 
  | c — константи
  | op(e1, ..., en) — примітивні операції
  | if e1 then e2 else e3 — умовні гілки
  | let x = e1 in e2 — визначеннях змінних
  | x — змінних
  | let rec x y1 ... yn = e1 in e2 — визначення функції e2 (взаємно рекурсивні)
  | e e1 ... en — функціональні програми
  | (e1, ..., en) — створення кортежу
  | let (x1,..., xn) = e1 in e2 — читання з кортежів
  | Array.create e1 e2 — створення масиву
  | e1.(e2) — читання з масивів
  | e1.(e2) <- e3 — запис в масиви
```

Він виражається як тип даних ML Syntax.t у модулі syntax.ml.
Вирази (такі як let і let rec), що визначають нові змінні,
також включають їх типи, які не показані вище. Ці типи
виражаються Type.t, визначеним у type.ml.

```
T ::= типи
  | π — примітивні типи
  | T1 -> ... -> Tn -> T — типи функцій
  | T1 * ... * Tn — типів кортежів
  | T array — типи масивів
  | α — змінні типу α
```

Останні «змінні типу» будуть використані для визначення типу.

До речі, компілятор MinCaml не підтримує автоматично так зване
часткове застосування функцій каррі. Тобто кожна функція потребує
всіх аргументів одночасно. Якщо ви бажаєте часткового застосування,
вам потрібно визначити проміжну функцію вручну, наприклад
let rec f_123 x = f 123 x у f_123. (Якщо ви знаєте мову Scheme,
вона схожа в цьому відношенні.)

Також немає «посилальних комірок», необхідних для імперативного
програмування, але їх можна замінити масивами лише з одним
елементом. Зокрема, ref e можна замінити на Array.create 1 e,
!e на e.(0), а e1 := e2 на e1.(0) <- e2.

