Прискорений курс MinCaml компілятора
====================================
Ейдзіро Суміі, Університет Токіо, 2005

Зміст
-----

* Що це?
* Makefile проєкту MinCaml
* Головна програма
* Синтаксис і типи MinCaml
* Політика компіляції
* Лексичний аналіз
* Парсер
* Вивід типів
* K-нормалізація
* α-конверсія
* β-редукція
* Редукція вкладених let
* Inline експансія
* Згортка констант
* Елімінація необов'язкових дефініцій
* Closure Conversion
* Генерація байткоду і компіляція бінарного коду
* Оптимізація безпосередніх операндів
* Алокація регістрів
* Генерація асемблерного коду

Що це?
------

Цей документ є підручником з описом MinCaml,
компілятора підмножини мови програмування ML.
Компілятор MinCaml розроблено в дослідницькому
програмному проекті «Красивий компілятор ML у Японії»
з метою популяризації простої та потужної мови програмування ML
і розриву негативної спіралі «Я не використовую ML,
тому що я не знаю ML». Він реалізований на мета мові
ML під назвою Objective Caml. Оскільки цей підручник
передбачає певний досвід програмування ML як передумову,
будь ласка, спочатку подивіться «Programmin in ML» Роберта Харпера.

[Застереження: цей підручник англійською мовою є попереднім
перекладом японської версії та все ще може мати багато недоліків,
як технічно, так і лінгвістично. Академічна стаття більш повна.]

[Оновлення від 17 вересня 2008 р.: тепер підтримується
PowerPC (на додаток до SPARC), завдяки пані Масуко та
професору Асаї з університету Очаномідзу. Ви повинні
виконати ./to_ppc або ./to_sparc перед make.]

[Ще одне оновлення від 17 вересня 2008 р.: розподільник
регістрів тепер використовує простіший алгоритм. У попередніх
версіях відсутнє зворотне відстеження (ToSpill і NoSpill).]

[Оновлення від 27 серпня 2012 р.: тепер підтримується
x86 із SSE2 (Pentium 4 або новіша версія). Будь ласка,
виконайте ./to_x86 перед make.]

Makefile проєкту MinCaml
------------------------

Після завантаження компілятора MinCaml перегляньте його Makefile.
Тут описано, як скомпілювати сам MinCaml.

Makefile MinCaml використовує зручний інструмент під назвою
OCamlMakefile (рядок містить OCamlMakefile внизу). Просто
перерахувавши файли, необхідні для MinCaml у рядку SOURCES = ...,
ви можете створити байт-код інтерпретатор min-caml, виконавши
команду "make byte-code". Подібним чином ви можете отримати
нативний код min-caml.opt за допомогою "make native-code".
Крім того, "make top" створює інтерактивне середовище OCaml
верхнього рівня min-caml.top, де за замовчуванням
завантажуються модулі MinCaml. Це зручно для дебага та експериментів.

Makefile MinCaml також має функцію автоматичного тестування.
Помістіть код ML "program-name.ml" у каталог test, напишіть 
назву програми в рядку TESTS = ... і запустіть "make do_test".
Потім результат, створений OCaml (назва-програми.ans) і результат
(назва-програми.res) збірки, згенерованої MinCaml (назва-програми.s),
автоматично порівнюються, а їх різниця виводиться в "назва-програми.cmp".
Зазвичай він порожній, тому що не повинно бути ніякої різниці,
поки компіляція та виконання вдалися.

Вам потрібне середовище SPARC з компілятором gcc і асемблером
для виконання скомпільованої програми. Однак це не обов'язково
для простого створення збірки SPARC.

Головна програма
----------------

Далі подивіться на основну програму MinCaml main.ml. Виконання
компілятора починається з його низу let () = ....

По-перше, ми обробляємо параметри за допомогою стандартної
бібліотеки Arg OCaml. Параметр -inline вказує максимальний
розмір функцій, які будуть вбудовані, а -iter визначає
максимальну кількість оптимізацій для ітерації. (Деталі будуть пояснені пізніше.)

Інші аргументи командного рядка вважаються іменами програм,
які збираються. Функція Main.file генерує збірку SPARC "назва-програми.s"
із джерела ML «назва-програми.ml».

Для налагодження та експериментів також надається функція Main.string,
яка компілює рядковий аргумент і відображає результат у стандартному виводі.

Ядром main.ml є функція Main.lexbuf. За наявності аргументу буфера
він застосовується в такому порядку: лексичний аналіз (Lexer.token),
аналіз (Parser.exp), визначення типу (Typing.f), K-нормалізація (KNormal.f),
α-перетворення (Alpha.f). ), оптимізації (iter), перетворення
закриття (Closure.f), генерація коду віртуальної машини (Virtual.f),
13-розрядна негайна оптимізація SPARC (Simm13.f), розподіл
реєстрів (RegAlloc.f) і генерація складання (Emit) .f).

Функція оптимізації iter повторює наступні п’ять оптимізацій,
доки її результат не перестане змінюватися або кількість ітерацій
не досягне верхньої межі, визначеної -iter: β-зменшення (Beta.f),
зменшення вкладеного let (Assoc.f), вбудоване розширення (Inline.f),
постійне згортання (ConstFold.f) і видалення непотрібних визначень (Elim.f).

Незабаром ми пояснимо подробиці цих перекладів і оптимізацій.

Синтаксис і типи MinCaml
------------------------

MinCaml є підмножиною ML. За винятком деяких деталей,
таких як пріоритет і круглі дужки, він має такий синтаксис.

```
e ::= вирази 
  | c — константи
  | op(e1, ..., en) — примітивні операції
  | if e1 then e2 else e3 — умовні гілки
  | let x = e1 in e2 — визначеннях змінних
  | x — змінних
  | let rec x y1 ... yn = e1 in e2 — визначення функції e2 (взаємно рекурсивні)
  | e e1 ... en — функціональні програми
  | (e1, ..., en) — створення кортежу
  | let (x1,..., xn) = e1 in e2 — читання з кортежів
  | Array.create e1 e2 — створення масиву
  | e1.(e2) — читання з масивів
  | e1.(e2) <- e3 — запис в масиви
```

Він виражається як тип даних ML Syntax.t у модулі syntax.ml.
Вирази (такі як let і let rec), що визначають нові змінні,
також включають їх типи, які не показані вище. Ці типи
виражаються Type.t, визначеним у type.ml.

```
T ::= типи
  | π — примітивні типи
  | T1 -> ... -> Tn -> T — типи функцій
  | T1 * ... * Tn — типів кортежів
  | T array — типи масивів
  | α — змінні типу α
```

Останні «змінні типу» будуть використані для визначення типу.

До речі, компілятор MinCaml не підтримує автоматично так зване
часткове застосування функцій каррі. Тобто кожна функція потребує
всіх аргументів одночасно. Якщо ви бажаєте часткового застосування,
вам потрібно визначити проміжну функцію вручну, наприклад
let rec f_123 x = f 123 x у f_123. (Якщо ви знаєте мову Scheme,
вона схожа в цьому відношенні.)

Також немає «посилальних комірок», необхідних для імперативного
програмування, але їх можна замінити масивами лише з одним
елементом. Зокрема, ref e можна замінити на Array.create 1 e,
!e на e.(0), а e1 := e2 на e1.(0) <- e2.

Політика компіляції
-------------------

Загалом компіляція означає переклад програм з мови високого
рівня на мову нижчого рівня. Наприклад, наведена нижче функція
MinCaml, яка обчислює найбільший спільний дільник двох
невід'ємних цілих чисел,

```
let rec gcd m n =
    if m = 0 then n else
    if m <= n then gcd m (n - m) else
    gcd n (m - n)
```

компілюється в наступну збірку SPARC.

```
gcd.7:
        cmp     %i2, 0
        bne     be_else.18
        nop
        mov     %i3, %i2
        retl
        nop
be_else.18:
        cmp     %i2, %i3
        bg      ble_else.19
        nop
        sub     %i3, %i2, %i3
        b       gcd.7
        nop
ble_else.19:
        sub     %i2, %i3, %o5
        mov     %i3, %i2
        mov     %o5, %i3
        b       gcd.7
        nop
```

На перший погляд, між двома мовами існує величезна прірва. Компілятор MinCaml
усуває цю прогалину, визначаючи відповідні проміжні мови та застосовуючи
прості переклади один за іншим. Основні п’ять прогалин між складанням MinCaml і SPARC:

Типи. MinCaml має типи та перевірку типів, але збірка не має такого механізму.
Вкладені вирази. У MinCaml ви можете писати скільки завгодно складні вирази,
наприклад 1+2-(3+(4-5)), але збірка може виконувати лише одну операцію за
однією інструкцією. Визначення вкладених функцій. У MinCaml ви можете
визначити функцію всередині іншої функції, наприклад

```
let rec make_adder x =
  let rec adder y = x + y in
  adder in (make_adder 3) 7
```

але збірка має лише "мітки" верхнього рівня.

MinCaml має такі структури даних, як кортежі та масиви, а асемблер або машинні кода — ні.
У MinCaml ви можете використовувати скільки завгодно змінних,
але лише обмежена кількість регістрів може використовуватися в асемблері.
Щоб подолати ці прогалини, MinCaml застосовує такі перетворення, як

Вивід типів
К-нормалізація
Конверсія функцій
Генерація коду віртуальної машини
Алокація регістрів

в такому порядку. Далі ми пояснимо ці переклади та оптимізацію.

Лексичний аналіз
----------------

Якщо дивитися з комп’ютера, то навіть програми ML – це лише
послідовності символів. Наприклад, попередня програма gcd виглядає так:

`l` `e` `t` ` ` `r` `e` `c` ` ` `g` `c` `d` ` ` `m` ` ` `n` ` ` `=` ...

Оскільки ми не можемо нічого зробити з таким рядком, як він є,
ми спочатку розділяємо його на лексеми, такі як:

`let` `rec` `gcd` `m` `n` `=` ...

Цей процес називається лексичним аналізом.

Хоча існує багато методів лексичного аналізу, ми тут використовуємо
інструмент під назвою ocamllex, який розроблено для лексичного
аналізу в OCaml. Файл lexer.mll. Ми залишаємо деталі ocamllex
у його посібнику та пояснюємо лише основні моменти.
Ми записуємо список правил, таких як

```
| "-"? digit+
     { INT(int_of_string (Lexing.lexeme lexbuf))}
```

у синтаксисі, подібному до шаблону, що означає, що "якщо
рядок збігається з регулярним виразом `'-'? digit+`,
поверніть маркер INT." Тип даних токенів (наприклад, INT)
визначається в parser.mly, який пояснюється далі. Фразу
`Lexing.lexeme lexbuf` можна розглядати як «магічне заклинання»,
що означає рядок, що аналізується.

Парсер
------

Тепер, коли виконується лексичний аналіз, замість рядків, як

`1` `2` `3` `-` `4` `5` `6` `+` `7` `8` `9`

ми маємо такі послідовності токенів, як

`123` `-` `456` `+` `789`.

Однак ми все ще не можемо виконати будь-яку
високорівневу обробку такої плоскої послідовності,
як вище. Наприклад, ми маємо розпізнати «123-456+789»
як «(123-456)+789», а не «123-(456+789)». З точки зору
типу даних Syntax.t, визначеного в syntax.ml, нам
потрібне дерево розбору на зразок:

`Add (Sub (Int 123, Int 456), Int 789)`

Цей процес перекладу послідовності токенів у
дерево аналізу називається синтаксичним аналізом.
Компілятор MinCaml використовує інструмент під
назвою ocamlyacc для реалізації синтаксичного
аналізу у файлі parser.mly.

Вміст parser.mly більш-менш схожий на вміст lexer.mll.
У ньому наведено список відповідності шаблонів із
послідовностей токенів для розбору дерев, наприклад:

```
| exp PLUS exp { Add($1, $3) }
```

$1 і $3 означають перший і третій синтаксичні елементи (обидва в цьому випадку є exp).

Це визначення синтаксису майже таке ж, як і раніше
описані вирази e, але один момент потребує обережності.
У ML застосування функції позначається лише послідовністю
виразів. Отже, якщо ви пишете x - y, незрозуміло, чи ви
віднімаєте ціле число y від цілого числа x, чи застосовуєте
функцію x до аргументу -y! Таким чином, ми відрізняємо прості
вирази simple_exp, які можуть бути аргументами функції без
додаткових дужок, від загальних виразів exp. Наприклад,
оскільки -y не є простим_виразом, попередній вираз, як
відомо, є цілим відніманням, а не застосуванням функції.

parser.mly також визначає пріоритет різних синтаксичних
і бінарних операторів, а також тип даних токенів, згаданих у lexer.mll.

До речі, щоразу, коли потрібен тип змінної (як у let),
він надається новою, невизначеною змінною типу Var(ref None)
на даний момент. Цей момент буде пояснено далі в висновку типу.

Вивід типів
-----------

Як і в звичайному ML, MinCaml визначає типи змінних і функцій,
навіть якщо вони не записані в програмі. Ця функція називається
виведенням типу. Виведення типу загалом дуже корисне для програм
із поліморфними функціями та функціями вищого порядку зокрема (хоча
сам MinCaml є мономорфним, як зазначено синтаксисом типів).

Основою виведення типу в MinCaml є функція Typing.g. Ця функція
приймає середовище типу env (відображення імен змінних у їхні типи)
і вираз e та повертає виведений тип e. Він також перевіряє типи
підвиразів. Якщо знайдено змінну невизначеного типу, вона
замінюється на відповідний тип. Ця перевірка та підстановка
реалізуються функцією Typing.unify.

Наприклад, у випадку цілочисельного додавання
e1 + e2 (або Add(e1,e2) у термінах Syntax.t),
ми спочатку визначаємо тип підвиразу e1 за допомогою g env e1,
який перевіряється на int за допомогою unify. Те саме для e2.
Потім ми повертаємо int як тип усього виразу.

Трохи складнішим випадком є застосування функції e e1 ... en,
де e — функція, а від e1 до en — її аргументи. У цьому випадку
тип функції можна визначити за допомогою g env e, а типи
аргументів — за допомогою g env e1 до g env en, але тип
результату – ні. Таким чином, ми створюємо нову невизначену
змінну типу t і викликаємо unify, щоб g env e дорівнював типу
функції від g env e1, ..., g env en до t. Потім ми повертаємо
t як тип усього виразу.

Коли вводиться нова змінна, як у let і let rec, середовище
типу env розширюється. І навпаки, коли з’являється змінна x,
її тип визначається пошуком env. Однак, коли змінна не знайдена
в середовищі типу, вона розглядається як зовнішня змінна,
їй призначається нова невизначена змінна типу та додається
до спеціального середовища типу extenv для зовнішніх змінних.
Ця функція є специфічною для MinCaml і недоступна у звичайному
ML. Завдяки цьому зовнішні змінні можна використовувати без оголошення.

Функція Typing.unify рекурсивно перевіряє, чи є два дані типи рівними,
і, якщо один із типів є невизначеною змінною типу Type.var(ref None),
замінює її іншим типом, щоб вони стали рівними. Однак перед цією
заміною перевіряється, чи з’являється змінна типу всередині іншого
типу. Цей процес називається перевіркою виникнення. Це необхідно
для того, щоб отриманий тип не мав циклу. Наприклад, якщо ми
об'єднаємо змінну типу α (без перевірки) із функціональним
типом int->α, результатом буде нескінченний тип, наприклад
int->int->int->..., оскільки α = int->α ! Щоб запобігти таким
випадкам, необхідна перевірка, навіть якщо спочатку це може
здатися загадковим.

Після завершення визначення типу (чи через помилку типу, чи
через звичайне завершення) Typing.deref_typ замінює всі змінні
типу їхнім вмістом для спрощення. Змінні типу, які ще не визначені,
за бажанням замінюються на int. Ця функція також властива MinCaml.

K-нормалізація
--------------

Ми вже сказали, що «компіляція — це подолання розривів між
мовою високого рівня та мовою низького рівня», однією з
яких є «вкладені вирази». Наприклад, ML (як і більшість мов)
може відразу обчислювати значення таких виразів, як a + b + c - d,
але звичайний асемблер а не має таких інструкцій.

Ця прогалина подолана трансформацією під назвою K-нормалізація,
яка визначає кожен проміжний результат обчислення як змінну.
(Назва K-нормалізація походить від компілятора під назвою ML Kit.)
Наприклад, попередній вираз можна перекласти так:

```
let tmp1 = a + b in
let tmp2 = tmp1 + c in
    tmp2 - d
```

У MinCaml KNormal.g є ядром K-нормалізації, а KNormal.t є типом
даних K-нормалізованих виразів (так звані K-нормальні форми).
KNormal.g приймає вираз перед K-нормалізацією з типом середовища
env і повертає вираз після K-нормалізації в парі з його типом.
(Типи передаються лише для анотування визначень змінних у let
і не є центральними для суті K-нормалізації.)

Наприклад, у випадку e1 + e2, e1 спочатку K-нормалізується g
env e1, результат якого прив'язується let до змінної x. Тоді
e2 також K-нормалізується за допомогою g env e2, результат якого
прив’язаний за допомогою let до змінної y, а вираз x + y
повертається з типом int.

Щоб вставити такий let, ми використовуємо допоміжну функцію під
назвою insert_let. Вона приймає вираз e, створює нову змінну x і
повертає вираз let x = e in ... (хоча, якщо e є змінною в першу
чергу, insert_let використовує цю змінну як x і не вставляє let
насправді). Вона також використовує функцію «продовження» k,
застосовує її до x і використовує її результат для виразу після
in (тіло «...» вище).

До речі, окрім K-нормалізації, KNormal.g також перетворює логічні
значення true та false у цілі числа 1 та 0. Крім того, порівняння
та умовні розгалуження переводяться у комбіновані форми, як if e1
<= e2 then e3 else e4 з окремих такі форми, як e1 <= e2 і якщо e,
то e1, інакше e2. Цей переклад заповнює одну з прогалин між MinCaml
і звичайною збіркою, де порівняння та розгалуження поєднуються.
Якщо умова e не є порівнянням, вона перекладається на порівняння,
якщо e <> 0, тоді e1 else e2. Крім того, перекладаючи if (не e)
then e1 else e2 на if e then e2 else e1 тощо, усі булеві вирази
та умовні розгалуження опиняються в будь-якій із двох форм

```
if e1 = e2, then e3, else e4
```

і

```
if e1 <= e2, then e3, else e4.
```

Це перетворення відрізняється від K-нормалізації, але реалізовано
разом із KNormal.g лише тому, що їх розділення вимагає додаткової
роботи для визначення проміжного типу даних.

Крім того, використання зовнішніх змінних обмежується викликами
зовнішніх функцій (KNormal.ExtFunApp) або посиланнями на зовнішні
масиви (KNormal.ExtArray), оскільки вони необхідні й достатні для
більшості програм. Це обмеження також реалізується разом з K-нормалізація.

α-конверсія
-----------

Тепер, коли K-нормалізація завершена, ми переходимо до оптимізацій,
але перед ними виконуємо α-перетворення, яке присвоює різні імена
різним змінним. Це перетворення є необхідним, оскільки різні змінні
з однаковими іменами ускладнюють різні процеси. Наприклад, він
перетворює вираз let x = 123 in let x = 456 in x + x в наступний вираз:
let x1 = 123 у let x2 = 456 у x2 + x2.

α-перетворення реалізовано в Alpha.g. Воно бере неперекладений вираз
e з відображенням env з неперекладених імен змінних на перекладені імена змінних
і повертає перекладений вираз. Наприклад, у випадку виразу let x = e1 in e2
ми спочатку транслюємо e1, створюємо нову змінну x', додаємо до env
відображення x у x' і транслюємо e2. Цей процес також подібний у
випадках let rec і LetTuple, хоча вони можуть здаватися більш складними.

До речі, зовнішні змінні не α-перетворюються, оскільки вони не
зареєстровані в env (див. функцію Alpha.find). Така поведінка є
навмисною: зв'язування (лінкінг) не працюватиме, якщо змінити назви зовнішніх змінних.
